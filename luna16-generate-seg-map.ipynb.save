{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "# imports\n",
    "\n",
    "from PIL import Image\n",
    "from glob import glob\n",
    "import pandas as pd\n",
    "import skimage, os\n",
    "from skimage.morphology import ball, disk, dilation, binary_erosion, remove_small_objects, erosion, closing, reconstruction, binary_closing\n",
    "from skimage.measure import label,regionprops, perimeter\n",
    "from skimage.morphology import binary_dilation, binary_opening, convex_hull_image\n",
    "from skimage.filters import roberts, sobel\n",
    "from skimage import measure, feature\n",
    "from skimage.segmentation import clear_border\n",
    "from skimage import data\n",
    "from scipy import ndimage as ndi\n",
    "import matplotlib.pyplot as plt\n",
    "from mpl_toolkits.mplot3d.art3d import Poly3DCollection\n",
    "import pydicom\n",
    "import scipy.misc\n",
    "import numpy as np\n",
    "import SimpleITK as sitk\n",
    "from matplotlib import pyplot as plt\n",
    "from tqdm import tqdm\n",
    "\n",
    "luna_path = '/vol/bitbucket/xz1919/Imperial-Individual-Project/processed_data_raw/'\n",
    "luna_subset_path = '/vol/bitbucket/xz1919/Imperial-Individual-Project/processed_data_raw/lungs_roi_npy/'\n",
    "file_list=glob(luna_subset_path+\"*.npy\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_segmented_lungs(im, plot=False):\n",
    "    '''\n",
    "    This funtion segments the lungs from the given 2D slice.\n",
    "    '''\n",
    "    plt_number = 0\n",
    "    # Original image label: 0\n",
    "    if plot:\n",
    "        f, plots = plt.subplots(12, 1, figsize=(5, 40))\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(im, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "\n",
    "    # Step 1: Convert into a binary image.\n",
    "    # image label: 1\n",
    "    binary = im < -604\n",
    "    if plot:\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(binary, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "    # Step 2: Remove the blobs connected to the border of the image.\n",
    "    # image label: 2\n",
    "    cleared = clear_border(binary)\n",
    "    if plot:\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(cleared, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "    # Step 3: Label the image.\n",
    "    # image label: 3\n",
    "    label_image = label(cleared)\n",
    "    if plot:\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(label_image, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "        \n",
    "    label_image_save = label_image.copy()\n",
    "\n",
    "    # Step 4: Keep the labels with 2 largest areas and segment two lungs.\n",
    "    # image label: 4\n",
    "    areas = [r.area for r in regionprops(label_image)]\n",
    "    areas.sort()\n",
    "    labels = []\n",
    "    if len(areas) > 2:\n",
    "        for region in regionprops(label_image):\n",
    "            if region.area < areas[-2]:\n",
    "                for coordinates in region.coords:\n",
    "                    label_image[coordinates[0], coordinates[1]] = 0\n",
    "            else:\n",
    "                coordinates = region.coords[0]\n",
    "                labels.append(label_image[coordinates[0], coordinates[1]])\n",
    "    else:\n",
    "        labels = [1, 2]\n",
    "    if plot:\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(label_image, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "    # Step 5: Fill in the small holes inside the mask of lungs which we seperate right and left lung. r and l are symbolic and they can be actually left and right!\n",
    "    # image labels: 5, 6\n",
    "    r = label_image == labels[0]\n",
    "    l = label_image == labels[1]\n",
    "    r_edges = roberts(r)\n",
    "    l_edges = roberts(l)\n",
    "    r = ndi.binary_fill_holes(r_edges)\n",
    "    l = ndi.binary_fill_holes(l_edges)\n",
    "    if plot:\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(r, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(l, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "\n",
    "    # Step 6: convex hull of each lung\n",
    "    # image labels: 7, 8\n",
    "    r = convex_hull_image(r)\n",
    "    l = convex_hull_image(l)\n",
    "    if plot:\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(r, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(l, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "    # Step 7: joint two separated right and left lungs.\n",
    "    # image label: 9\n",
    "    sum_of_lr = r + l\n",
    "    binary = sum_of_lr > 0\n",
    "    if plot:\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(binary, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "    # Step 8: Closure operation with a disk of radius 10. This operation is\n",
    "    # to keep nodules attached to the lung wall.\n",
    "    # image label: 10\n",
    "    selem = disk(10)\n",
    "    binary = binary_closing(binary, selem)\n",
    "    if plot:\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(binary, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "    # Step 9: Superimpose the binary mask on the input image.\n",
    "    # image label: 11\n",
    "    get_high_vals = binary == 0\n",
    "    im[get_high_vals] = 0\n",
    "    if plot:\n",
    "        plots[plt_number].axis('off')\n",
    "        plots[plt_number].set_title(f'{plt_number}')\n",
    "        plots[plt_number].imshow(im, cmap=plt.cm.bone)\n",
    "        plt_number += 1\n",
    "\n",
    "    return im, label_image, binary, label_image_save"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[10], line 3\u001b[0m\n\u001b[1;32m      1\u001b[0m imgs \u001b[39m=\u001b[39m []\n\u001b[1;32m      2\u001b[0m \u001b[39mfor\u001b[39;00m file \u001b[39min\u001b[39;00m file_list:\n\u001b[0;32m----> 3\u001b[0m     imgs\u001b[39m.\u001b[39mappend((np\u001b[39m.\u001b[39;49mload(file), file))\n\u001b[1;32m      5\u001b[0m img_tuple \u001b[39m=\u001b[39m [(get_segmented_lungs(im), filename) \u001b[39mfor\u001b[39;00m im, filename \u001b[39min\u001b[39;00m imgs]\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/numpy/lib/npyio.py:412\u001b[0m, in \u001b[0;36mload\u001b[0;34m(file, mmap_mode, allow_pickle, fix_imports, encoding, max_header_size)\u001b[0m\n\u001b[1;32m    410\u001b[0m _ZIP_SUFFIX \u001b[39m=\u001b[39m \u001b[39mb\u001b[39m\u001b[39m'\u001b[39m\u001b[39mPK\u001b[39m\u001b[39m\\x05\u001b[39;00m\u001b[39m\\x06\u001b[39;00m\u001b[39m'\u001b[39m \u001b[39m# empty zip files start with this\u001b[39;00m\n\u001b[1;32m    411\u001b[0m N \u001b[39m=\u001b[39m \u001b[39mlen\u001b[39m(\u001b[39mformat\u001b[39m\u001b[39m.\u001b[39mMAGIC_PREFIX)\n\u001b[0;32m--> 412\u001b[0m magic \u001b[39m=\u001b[39m fid\u001b[39m.\u001b[39;49mread(N)\n\u001b[1;32m    413\u001b[0m \u001b[39m# If the file size is less than N, we need to make sure not\u001b[39;00m\n\u001b[1;32m    414\u001b[0m \u001b[39m# to seek past the beginning of the file\u001b[39;00m\n\u001b[1;32m    415\u001b[0m fid\u001b[39m.\u001b[39mseek(\u001b[39m-\u001b[39m\u001b[39mmin\u001b[39m(N, \u001b[39mlen\u001b[39m(magic)), \u001b[39m1\u001b[39m)  \u001b[39m# back-up\u001b[39;00m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "# imgs = []\n",
    "# for file in file_list:\n",
    "#     imgs.append((np.load(file), file))\n",
    "\n",
    "# img_tuple = [(get_segmented_lungs(im), filename) for im, filename in imgs]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "  0%|          | 3/2217 [00:04<56:22,  1.53s/it]\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[20], line 26\u001b[0m\n\u001b[1;32m     24\u001b[0m \u001b[39mfor\u001b[39;00m filename \u001b[39min\u001b[39;00m tqdm(file_list):\n\u001b[1;32m     25\u001b[0m     im \u001b[39m=\u001b[39m np\u001b[39m.\u001b[39mload(filename)\n\u001b[0;32m---> 26\u001b[0m     im, label_image, binary, areas \u001b[39m=\u001b[39m get_segmented_lungs(im)\n\u001b[1;32m     27\u001b[0m     filename \u001b[39m=\u001b[39m filename\u001b[39m.\u001b[39msplit(\u001b[39m'\u001b[39m\u001b[39m/\u001b[39m\u001b[39m'\u001b[39m)[\u001b[39m-\u001b[39m\u001b[39m1\u001b[39m][:\u001b[39m-\u001b[39m\u001b[39m4\u001b[39m]\n\u001b[1;32m     28\u001b[0m     cv2\u001b[39m.\u001b[39mimwrite(\u001b[39mf\u001b[39m\u001b[39m'\u001b[39m\u001b[39m{\u001b[39;00mluna_path\u001b[39m}\u001b[39;00m\u001b[39m/overlay/\u001b[39m\u001b[39m{\u001b[39;00mfilename\u001b[39m}\u001b[39;00m\u001b[39m.png\u001b[39m\u001b[39m'\u001b[39m, normalize(im))\n",
      "Cell \u001b[0;32mIn[14], line 107\u001b[0m, in \u001b[0;36mget_segmented_lungs\u001b[0;34m(im, plot)\u001b[0m\n\u001b[1;32m    103\u001b[0m \u001b[39m# Step 8: Closure operation with a disk of radius 10. This operation is\u001b[39;00m\n\u001b[1;32m    104\u001b[0m \u001b[39m# to keep nodules attached to the lung wall.\u001b[39;00m\n\u001b[1;32m    105\u001b[0m \u001b[39m# image label: 10\u001b[39;00m\n\u001b[1;32m    106\u001b[0m selem \u001b[39m=\u001b[39m disk(\u001b[39m10\u001b[39m)\n\u001b[0;32m--> 107\u001b[0m binary \u001b[39m=\u001b[39m binary_closing(binary, selem)\n\u001b[1;32m    108\u001b[0m \u001b[39mif\u001b[39;00m plot:\n\u001b[1;32m    109\u001b[0m     plots[plt_number]\u001b[39m.\u001b[39maxis(\u001b[39m'\u001b[39m\u001b[39moff\u001b[39m\u001b[39m'\u001b[39m)\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/skimage/morphology/misc.py:39\u001b[0m, in \u001b[0;36mdefault_footprint.<locals>.func_out\u001b[0;34m(image, footprint, *args, **kwargs)\u001b[0m\n\u001b[1;32m     37\u001b[0m \u001b[39mif\u001b[39;00m footprint \u001b[39mis\u001b[39;00m \u001b[39mNone\u001b[39;00m:\n\u001b[1;32m     38\u001b[0m     footprint \u001b[39m=\u001b[39m _default_footprint(image\u001b[39m.\u001b[39mndim)\n\u001b[0;32m---> 39\u001b[0m \u001b[39mreturn\u001b[39;00m func(image, footprint\u001b[39m=\u001b[39;49mfootprint, \u001b[39m*\u001b[39;49margs, \u001b[39m*\u001b[39;49m\u001b[39m*\u001b[39;49mkwargs)\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/skimage/_shared/utils.py:282\u001b[0m, in \u001b[0;36mdeprecate_kwarg.__call__.<locals>.fixed_func\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    279\u001b[0m         kwargs[new_arg] \u001b[39m=\u001b[39m kwargs\u001b[39m.\u001b[39mpop(old_arg)\n\u001b[1;32m    281\u001b[0m \u001b[39m# Call the function with the fixed arguments\u001b[39;00m\n\u001b[0;32m--> 282\u001b[0m \u001b[39mreturn\u001b[39;00m func(\u001b[39m*\u001b[39;49margs, \u001b[39m*\u001b[39;49m\u001b[39m*\u001b[39;49mkwargs)\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/skimage/morphology/binary.py:156\u001b[0m, in \u001b[0;36mbinary_closing\u001b[0;34m(image, footprint, out)\u001b[0m\n\u001b[1;32m    128\u001b[0m \u001b[39m\u001b[39m\u001b[39m\"\"\"Return fast binary morphological closing of an image.\u001b[39;00m\n\u001b[1;32m    129\u001b[0m \n\u001b[1;32m    130\u001b[0m \u001b[39mThis function returns the same result as grayscale closing but performs\u001b[39;00m\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m    153\u001b[0m \n\u001b[1;32m    154\u001b[0m \u001b[39m\"\"\"\u001b[39;00m\n\u001b[1;32m    155\u001b[0m dilated \u001b[39m=\u001b[39m binary_dilation(image, footprint)\n\u001b[0;32m--> 156\u001b[0m out \u001b[39m=\u001b[39m binary_erosion(dilated, footprint, out\u001b[39m=\u001b[39;49mout)\n\u001b[1;32m    157\u001b[0m \u001b[39mreturn\u001b[39;00m out\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/skimage/morphology/misc.py:39\u001b[0m, in \u001b[0;36mdefault_footprint.<locals>.func_out\u001b[0;34m(image, footprint, *args, **kwargs)\u001b[0m\n\u001b[1;32m     37\u001b[0m \u001b[39mif\u001b[39;00m footprint \u001b[39mis\u001b[39;00m \u001b[39mNone\u001b[39;00m:\n\u001b[1;32m     38\u001b[0m     footprint \u001b[39m=\u001b[39m _default_footprint(image\u001b[39m.\u001b[39mndim)\n\u001b[0;32m---> 39\u001b[0m \u001b[39mreturn\u001b[39;00m func(image, footprint\u001b[39m=\u001b[39;49mfootprint, \u001b[39m*\u001b[39;49margs, \u001b[39m*\u001b[39;49m\u001b[39m*\u001b[39;49mkwargs)\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/skimage/_shared/utils.py:282\u001b[0m, in \u001b[0;36mdeprecate_kwarg.__call__.<locals>.fixed_func\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    279\u001b[0m         kwargs[new_arg] \u001b[39m=\u001b[39m kwargs\u001b[39m.\u001b[39mpop(old_arg)\n\u001b[1;32m    281\u001b[0m \u001b[39m# Call the function with the fixed arguments\u001b[39;00m\n\u001b[0;32m--> 282\u001b[0m \u001b[39mreturn\u001b[39;00m func(\u001b[39m*\u001b[39;49margs, \u001b[39m*\u001b[39;49m\u001b[39m*\u001b[39;49mkwargs)\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/skimage/morphology/binary.py:47\u001b[0m, in \u001b[0;36mbinary_erosion\u001b[0;34m(image, footprint, out)\u001b[0m\n\u001b[1;32m     45\u001b[0m \u001b[39mif\u001b[39;00m out \u001b[39mis\u001b[39;00m \u001b[39mNone\u001b[39;00m:\n\u001b[1;32m     46\u001b[0m     out \u001b[39m=\u001b[39m np\u001b[39m.\u001b[39mempty(image\u001b[39m.\u001b[39mshape, dtype\u001b[39m=\u001b[39m\u001b[39mbool\u001b[39m)\n\u001b[0;32m---> 47\u001b[0m ndi\u001b[39m.\u001b[39;49mbinary_erosion(image, structure\u001b[39m=\u001b[39;49mfootprint, output\u001b[39m=\u001b[39;49mout,\n\u001b[1;32m     48\u001b[0m                    border_value\u001b[39m=\u001b[39;49m\u001b[39mTrue\u001b[39;49;00m)\n\u001b[1;32m     49\u001b[0m \u001b[39mreturn\u001b[39;00m out\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/scipy/ndimage/_morphology.py:387\u001b[0m, in \u001b[0;36mbinary_erosion\u001b[0;34m(input, structure, iterations, mask, output, border_value, origin, brute_force)\u001b[0m\n\u001b[1;32m    293\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39mbinary_erosion\u001b[39m(\u001b[39minput\u001b[39m, structure\u001b[39m=\u001b[39m\u001b[39mNone\u001b[39;00m, iterations\u001b[39m=\u001b[39m\u001b[39m1\u001b[39m, mask\u001b[39m=\u001b[39m\u001b[39mNone\u001b[39;00m, output\u001b[39m=\u001b[39m\u001b[39mNone\u001b[39;00m,\n\u001b[1;32m    294\u001b[0m                    border_value\u001b[39m=\u001b[39m\u001b[39m0\u001b[39m, origin\u001b[39m=\u001b[39m\u001b[39m0\u001b[39m, brute_force\u001b[39m=\u001b[39m\u001b[39mFalse\u001b[39;00m):\n\u001b[1;32m    295\u001b[0m \u001b[39m    \u001b[39m\u001b[39m\"\"\"\u001b[39;00m\n\u001b[1;32m    296\u001b[0m \u001b[39m    Multidimensional binary erosion with a given structuring element.\u001b[39;00m\n\u001b[1;32m    297\u001b[0m \n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m    385\u001b[0m \n\u001b[1;32m    386\u001b[0m \u001b[39m    \"\"\"\u001b[39;00m\n\u001b[0;32m--> 387\u001b[0m     \u001b[39mreturn\u001b[39;00m _binary_erosion(\u001b[39minput\u001b[39;49m, structure, iterations, mask,\n\u001b[1;32m    388\u001b[0m                            output, border_value, origin, \u001b[39m0\u001b[39;49m, brute_force)\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/scipy/ndimage/_morphology.py:234\u001b[0m, in \u001b[0;36m_binary_erosion\u001b[0;34m(input, structure, iterations, mask, output, border_value, origin, invert, brute_force)\u001b[0m\n\u001b[1;32m    232\u001b[0m \u001b[39mif\u001b[39;00m \u001b[39mnot\u001b[39;00m structure\u001b[39m.\u001b[39mflags\u001b[39m.\u001b[39mcontiguous:\n\u001b[1;32m    233\u001b[0m     structure \u001b[39m=\u001b[39m structure\u001b[39m.\u001b[39mcopy()\n\u001b[0;32m--> 234\u001b[0m \u001b[39mif\u001b[39;00m numpy\u001b[39m.\u001b[39;49mprod(structure\u001b[39m.\u001b[39;49mshape, axis\u001b[39m=\u001b[39;49m\u001b[39m0\u001b[39;49m) \u001b[39m<\u001b[39m \u001b[39m1\u001b[39m:\n\u001b[1;32m    235\u001b[0m     \u001b[39mraise\u001b[39;00m \u001b[39mRuntimeError\u001b[39;00m(\u001b[39m'\u001b[39m\u001b[39mstructure must not be empty\u001b[39m\u001b[39m'\u001b[39m)\n\u001b[1;32m    236\u001b[0m \u001b[39mif\u001b[39;00m mask \u001b[39mis\u001b[39;00m \u001b[39mnot\u001b[39;00m \u001b[39mNone\u001b[39;00m:\n",
      "File \u001b[0;32m<__array_function__ internals>:200\u001b[0m, in \u001b[0;36mprod\u001b[0;34m(*args, **kwargs)\u001b[0m\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/numpy/core/fromnumeric.py:3076\u001b[0m, in \u001b[0;36mprod\u001b[0;34m(a, axis, dtype, out, keepdims, initial, where)\u001b[0m\n\u001b[1;32m   2955\u001b[0m \u001b[39m@array_function_dispatch\u001b[39m(_prod_dispatcher)\n\u001b[1;32m   2956\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39mprod\u001b[39m(a, axis\u001b[39m=\u001b[39m\u001b[39mNone\u001b[39;00m, dtype\u001b[39m=\u001b[39m\u001b[39mNone\u001b[39;00m, out\u001b[39m=\u001b[39m\u001b[39mNone\u001b[39;00m, keepdims\u001b[39m=\u001b[39mnp\u001b[39m.\u001b[39m_NoValue,\n\u001b[1;32m   2957\u001b[0m          initial\u001b[39m=\u001b[39mnp\u001b[39m.\u001b[39m_NoValue, where\u001b[39m=\u001b[39mnp\u001b[39m.\u001b[39m_NoValue):\n\u001b[1;32m   2958\u001b[0m \u001b[39m    \u001b[39m\u001b[39m\"\"\"\u001b[39;00m\n\u001b[1;32m   2959\u001b[0m \u001b[39m    Return the product of array elements over a given axis.\u001b[39;00m\n\u001b[1;32m   2960\u001b[0m \n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m   3074\u001b[0m \u001b[39m    10\u001b[39;00m\n\u001b[1;32m   3075\u001b[0m \u001b[39m    \"\"\"\u001b[39;00m\n\u001b[0;32m-> 3076\u001b[0m     \u001b[39mreturn\u001b[39;00m _wrapreduction(a, np\u001b[39m.\u001b[39;49mmultiply, \u001b[39m'\u001b[39;49m\u001b[39mprod\u001b[39;49m\u001b[39m'\u001b[39;49m, axis, dtype, out,\n\u001b[1;32m   3077\u001b[0m                           keepdims\u001b[39m=\u001b[39;49mkeepdims, initial\u001b[39m=\u001b[39;49minitial, where\u001b[39m=\u001b[39;49mwhere)\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/numpy/core/fromnumeric.py:70\u001b[0m, in \u001b[0;36m_wrapreduction\u001b[0;34m(obj, ufunc, method, axis, dtype, out, **kwargs)\u001b[0m\n\u001b[1;32m     69\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39m_wrapreduction\u001b[39m(obj, ufunc, method, axis, dtype, out, \u001b[39m*\u001b[39m\u001b[39m*\u001b[39mkwargs):\n\u001b[0;32m---> 70\u001b[0m     passkwargs \u001b[39m=\u001b[39m {k: v \u001b[39mfor\u001b[39;00m k, v \u001b[39min\u001b[39;00m kwargs\u001b[39m.\u001b[39mitems()\n\u001b[1;32m     71\u001b[0m                   \u001b[39mif\u001b[39;00m v \u001b[39mis\u001b[39;00m \u001b[39mnot\u001b[39;00m np\u001b[39m.\u001b[39m_NoValue}\n\u001b[1;32m     73\u001b[0m     \u001b[39mif\u001b[39;00m \u001b[39mtype\u001b[39m(obj) \u001b[39mis\u001b[39;00m \u001b[39mnot\u001b[39;00m mu\u001b[39m.\u001b[39mndarray:\n\u001b[1;32m     74\u001b[0m         \u001b[39mtry\u001b[39;00m:\n",
      "File \u001b[0;32m~/.local/lib/python3.8/site-packages/numpy/core/fromnumeric.py:70\u001b[0m, in \u001b[0;36m<dictcomp>\u001b[0;34m(.0)\u001b[0m\n\u001b[1;32m     69\u001b[0m \u001b[39mdef\u001b[39;00m \u001b[39m_wrapreduction\u001b[39m(obj, ufunc, method, axis, dtype, out, \u001b[39m*\u001b[39m\u001b[39m*\u001b[39mkwargs):\n\u001b[0;32m---> 70\u001b[0m     passkwargs \u001b[39m=\u001b[39m {k: v \u001b[39mfor\u001b[39;00m k, v \u001b[39min\u001b[39;00m kwargs\u001b[39m.\u001b[39mitems()\n\u001b[1;32m     71\u001b[0m                   \u001b[39mif\u001b[39;00m v \u001b[39mis\u001b[39;00m \u001b[39mnot\u001b[39;00m np\u001b[39m.\u001b[39m_NoValue}\n\u001b[1;32m     73\u001b[0m     \u001b[39mif\u001b[39;00m \u001b[39mtype\u001b[39m(obj) \u001b[39mis\u001b[39;00m \u001b[39mnot\u001b[39;00m mu\u001b[39m.\u001b[39mndarray:\n\u001b[1;32m     74\u001b[0m         \u001b[39mtry\u001b[39;00m:\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "# plt.imshow(img_tuple[10][0][0], cmap=plt.cm.bone)\n",
    "import cv2\n",
    "\n",
    "# print(file_list[3])\n",
    "# print(np.min(np.load(file_list[1])))\n",
    "# plt.imshow(img_tuple[11][0][3])\n",
    "\n",
    "def normalize(arr):\n",
    "    \"\"\"Normalize a numpy array into range [0, 255]\"\"\"\n",
    "    arr_min = arr.min()\n",
    "    arr_max = arr.max()\n",
    "    normalized = 255 * (arr - arr_min) / (arr_max - arr_min)\n",
    "    return normalized.astype(np.uint8)\n",
    "\n",
    "def convert_binary(b):\n",
    "    return (b * 255).astype(np.uint8)\n",
    "\n",
    "import os\n",
    "os.makedirs(f\"{luna_path}/overlay\", exist_ok=True)\n",
    "os.makedirs(f\"{luna_path}/label_image\", exist_ok=True)\n",
    "os.makedirs(f\"{luna_path}/binary_image\", exist_ok=True)\n",
    "os.makedirs(f\"{luna_path}/area_image\", exist_ok=True)\n",
    "\n",
    "for filename in tqdm(file_list):\n",
    "    im = np.load(filename)\n",
    "    im, label_image, binary, areas = get_segmented_lungs(im)\n",
    "    filename = filename.split('/')[-1][:-4]\n",
    "    cv2.imwrite(f'{luna_path}/overlay/{filename}.png', normalize(im))\n",
    "    cv2.imwrite(f'{luna_path}/label_image/{filename}.png', label_image)\n",
    "    cv2.imwrite(f'{luna_path}/binary_image/{filename}.png', convert_binary(binary))\n",
    "    cv2.imwrite(f'{luna_path}/area_image/{filename}.png', areas)\n",
    "\n",
    "    # Image.fromarray(im).save(f'{luna_path}overlay/{filename}.png')\n",
    "    # Image.fromarray(label_image).save(f'{luna_path}label_image/{filename}.png')\n",
    "    # Image.fromarray(binary).save(f'{luna_path}binary_image/{filename}.png')\n",
    "    # Image.fromarray(areas).save(f'{luna_path}area_image/{filename}.png')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  },
  "orig_nbformat": 4,
  "vscode": {
   "interpreter": {
    "hash": "31f2aee4e71d21fbe5cf8b01ff0e069b9275f58929596ceb00d14d90e3e16cd6"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
